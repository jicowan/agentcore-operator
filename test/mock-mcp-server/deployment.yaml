apiVersion: v1
kind: Namespace
metadata:
  name: mock-mcp-server
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mock-mcp-server-script
  namespace: mock-mcp-server
data:
  main.py: |
    #!/usr/bin/env python3
    """Mock MCP Server with JSON-RPC 2.0 protocol and OAuth support."""
    import json
    import logging
    import os
    import ssl
    from http.server import HTTPServer, BaseHTTPRequestHandler
    from urllib.parse import urlparse, parse_qs
    from datetime import datetime

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    # GitHub OAuth configuration (set via environment variables)
    GITHUB_CLIENT_ID = os.environ.get('GITHUB_CLIENT_ID', '')
    GITHUB_CLIENT_SECRET = os.environ.get('GITHUB_CLIENT_SECRET', '')

    MOCK_TOOLS = [
        {
            "name": "get_weather",
            "title": "Weather Information Provider",
            "description": "Get current weather for a location",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "location": {"type": "string", "description": "City name"}
                },
                "required": ["location"]
            }
        },
        {
            "name": "calculate",
            "title": "Calculator",
            "description": "Perform basic arithmetic calculations",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "expression": {"type": "string", "description": "Math expression"}
                },
                "required": ["expression"]
            }
        },
        {
            "name": "get_time",
            "title": "Time Provider",
            "description": "Get current time in a timezone",
            "inputSchema": {
                "type": "object",
                "properties": {
                    "timezone": {"type": "string", "description": "Timezone name"}
                },
                "required": ["timezone"]
            }
        }
    ]

    class MCPRequestHandler(BaseHTTPRequestHandler):
        def do_GET(self):
            parsed_path = urlparse(self.path)
            
            # Health check endpoint
            if parsed_path.path == '/health':
                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps({"status": "healthy"}).encode())
                return
            
            # OAuth metadata endpoints
            if parsed_path.path in ['/.well-known/oauth-authorization-server', '/.well-known/openid-configuration']:
                logger.info("Returning OAuth metadata")
                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.end_headers()
                base_url = os.environ.get('BASE_URL', 'https://mcp-test.jicomusic.com')
                metadata = {
                    "issuer": base_url,
                    "authorization_endpoint": f"{base_url}/oauth/authorize",
                    "token_endpoint": f"{base_url}/oauth/token",
                    "grant_types_supported": ["client_credentials"],
                    "response_types_supported": ["token"],
                    "token_endpoint_auth_methods_supported": ["client_secret_post", "client_secret_basic"],
                    "scopes_supported": ["read", "write"]
                }
                self.wfile.write(json.dumps(metadata).encode())
                return
            
            # Not found
            self.send_response(404)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps({"error": "Not found"}).encode())

        def do_POST(self):
            parsed_path = urlparse(self.path)
            
            # OAuth token endpoint (mock - accepts any credentials)
            if parsed_path.path == '/oauth/token':
                content_length = int(self.headers.get('Content-Length', 0))
                body = self.rfile.read(content_length).decode('utf-8')
                logger.info(f"OAuth token request received: {body}")
                
                # Parse form data
                params = parse_qs(body)
                grant_type = params.get('grant_type', [''])[0]
                
                # Mock response - accept any credentials
                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.end_headers()
                token_response = {
                    "access_token": "gho_mock_github_token_" + os.urandom(16).hex(),
                    "token_type": "Bearer",
                    "expires_in": 3600,
                    "scope": "read write"
                }
                self.wfile.write(json.dumps(token_response).encode())
                return
            
            # MCP JSON-RPC 2.0 endpoint
            if parsed_path.path == '/':
                auth_header = self.headers.get('Authorization', '')
                if not auth_header.startswith('Bearer '):
                    logger.warning("Unauthorized POST request to root")
                    self.send_response(401)
                    self.send_header('Content-Type', 'application/json')
                    self.end_headers()
                    self.wfile.write(json.dumps({"error": "Unauthorized", "message": "Bearer token required"}).encode())
                    return
                
                # Read JSON-RPC request
                content_length = int(self.headers.get('Content-Length', 0))
                body = self.rfile.read(content_length).decode('utf-8')
                
                try:
                    request = json.loads(body)
                    logger.info(f"JSON-RPC request: {json.dumps(request)}")
                    
                    # Validate JSON-RPC 2.0 format
                    if request.get('jsonrpc') != '2.0':
                        self.send_jsonrpc_error(request.get('id'), -32600, "Invalid Request: jsonrpc must be '2.0'")
                        return
                    
                    method = request.get('method')
                    params = request.get('params', {})
                    request_id = request.get('id')
                    
                    # Handle notifications (no response needed)
                    if method and method.startswith('notifications/'):
                        logger.info(f"Received notification: {method}")
                        self.send_response(200)
                        self.send_header('Content-Type', 'application/json')
                        self.end_headers()
                        self.wfile.write(b'{}')
                        return
                    
                    # Handle initialize method (MCP lifecycle)
                    if method == 'initialize':
                        logger.info("Handling initialize request")
                        protocol_version = params.get('protocolVersion', '2025-11-25')
                        response = {
                            "jsonrpc": "2.0",
                            "id": request_id,
                            "result": {
                                "protocolVersion": protocol_version,
                                "capabilities": {
                                    "tools": {
                                        "listChanged": False
                                    }
                                },
                                "serverInfo": {
                                    "name": "mock-mcp-server",
                                    "version": "1.0.0",
                                    "description": "Mock MCP server for testing AWS Bedrock AgentCore integration"
                                }
                            }
                        }
                        self.send_jsonrpc_response(response)
                        return
                    
                    # Handle tools/list method
                    elif method == 'tools/list':
                        logger.info("Handling tools/list request")
                        response = {
                            "jsonrpc": "2.0",
                            "id": request_id,
                            "result": {
                                "tools": MOCK_TOOLS
                            }
                        }
                        self.send_jsonrpc_response(response)
                        return
                    
                    # Handle tools/call method
                    elif method == 'tools/call':
                        tool_name = params.get('name')
                        tool_args = params.get('arguments', {})
                        logger.info(f"Handling tools/call request for tool: {tool_name}")
                        
                        # Mock tool execution
                        if tool_name == 'get_weather':
                            location = tool_args.get('location', 'Unknown')
                            result = {
                                "content": [
                                    {
                                        "type": "text",
                                        "text": f"Weather in {location}: Sunny, 72Â°F"
                                    }
                                ]
                            }
                        elif tool_name == 'calculate':
                            expression = tool_args.get('expression', '0')
                            try:
                                result_value = eval(expression)
                                result = {
                                    "content": [
                                        {
                                            "type": "text",
                                            "text": f"Result: {result_value}"
                                        }
                                    ]
                                }
                            except Exception as e:
                                result = {
                                    "content": [
                                        {
                                            "type": "text",
                                            "text": f"Error: {str(e)}"
                                        }
                                    ],
                                    "isError": True
                                }
                        elif tool_name == 'get_time':
                            timezone = tool_args.get('timezone', 'UTC')
                            result = {
                                "content": [
                                    {
                                        "type": "text",
                                        "text": f"Current time in {timezone}: {datetime.now().isoformat()}"
                                    }
                                ]
                            }
                        else:
                            self.send_jsonrpc_error(request_id, -32601, f"Method not found: {tool_name}")
                            return
                        
                        response = {
                            "jsonrpc": "2.0",
                            "id": request_id,
                            "result": result
                        }
                        self.send_jsonrpc_response(response)
                        return
                    
                    # Unknown method
                    else:
                        self.send_jsonrpc_error(request_id, -32601, f"Method not found: {method}")
                        return
                
                except json.JSONDecodeError as e:
                    logger.error(f"JSON decode error: {e}")
                    self.send_jsonrpc_error(None, -32700, "Parse error")
                    return
                except Exception as e:
                    logger.error(f"Error handling request: {e}")
                    self.send_jsonrpc_error(request.get('id') if 'request' in locals() else None, -32603, f"Internal error: {str(e)}")
                    return
            
            # Not found
            self.send_response(404)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps({"error": "Not found"}).encode())
        
        def send_jsonrpc_response(self, response):
            """Send a JSON-RPC 2.0 response."""
            self.send_response(200)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps(response).encode())
            logger.info(f"JSON-RPC response: {json.dumps(response)}")
        
        def send_jsonrpc_error(self, request_id, code, message):
            """Send a JSON-RPC 2.0 error response."""
            error_response = {
                "jsonrpc": "2.0",
                "id": request_id,
                "error": {
                    "code": code,
                    "message": message
                }
            }
            self.send_response(200)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps(error_response).encode())
            logger.error(f"JSON-RPC error: {json.dumps(error_response)}")

        def log_message(self, format, *args):
            logger.info(f"{self.address_string()} - {format % args}")

    if __name__ == '__main__':
        import os
        import ssl
        port = int(os.environ.get('PORT', 8443))
        httpd = HTTPServer(('', port), MCPRequestHandler)
        
        # Enable HTTPS if cert files exist
        cert_file = os.environ.get('TLS_CERT', '/etc/tls/tls.crt')
        key_file = os.environ.get('TLS_KEY', '/etc/tls/tls.key')
        if os.path.exists(cert_file) and os.path.exists(key_file):
            context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
            context.load_cert_chain(cert_file, key_file)
            httpd.socket = context.wrap_socket(httpd.socket, server_side=True)
            logger.info(f"Mock MCP Server with GitHub OAuth and TLS running on port {port}")
        else:
            logger.info(f"Mock MCP Server with GitHub OAuth running on port {port} (no TLS)")
        
        if GITHUB_CLIENT_ID:
            logger.info(f"GitHub OAuth configured with client ID: {GITHUB_CLIENT_ID}")
        else:
            logger.warning("GitHub OAuth credentials not configured (GITHUB_CLIENT_ID not set)")
        
        httpd.serve_forever()
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mock-mcp-server
  namespace: mock-mcp-server
  labels:
    app: mock-mcp-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mock-mcp-server
  template:
    metadata:
      labels:
        app: mock-mcp-server
    spec:
      containers:
      - name: server
        image: python:3.11-slim
        command: ["python", "/app/main.py"]
        ports:
        - containerPort: 8080
          name: http
        env:
        - name: PORT
          value: "8080"
        - name: BASE_URL
          value: "https://mcp-test.jicomusic.com"
        volumeMounts:
        - name: script
          mountPath: /app
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
            scheme: HTTP
          initialDelaySeconds: 5
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
            scheme: HTTP
          initialDelaySeconds: 3
          periodSeconds: 5
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 200m
            memory: 256Mi
      volumes:
      - name: script
        configMap:
          name: mock-mcp-server-script
          defaultMode: 0755
---
apiVersion: v1
kind: Service
metadata:
  name: mock-mcp-server
  namespace: mock-mcp-server
  labels:
    app: mock-mcp-server
spec:
  type: ClusterIP
  selector:
    app: mock-mcp-server
  ports:
  - port: 80
    targetPort: 8080
    protocol: TCP
    name: http
